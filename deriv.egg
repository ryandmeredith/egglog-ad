(ruleset deriv)

(constructor D (Expr) Expr :unextractable)

(rewrite (D (App f x)) (App (D f) (D x)) :ruleset deriv)
(rewrite (D (Lam e)) (Lam (D e)) :ruleset deriv)
(rewrite (D (Var n)) (Var n) :ruleset deriv)
(rewrite (D (Const x)) (Pair (Const x) (Const 0.)) :ruleset deriv)
(rewrite (D (Cond b t f)) (Cond b (D t) (D f)) :ruleset deriv)

(rewrite (D (Add x y)) (Pair (Add (Fst (D x)) (Fst (D y))) (Add (Snd (D x)) (Snd (D y)))) :ruleset deriv)
(rewrite (D (Sub x y)) (Pair (Add (Fst (D x)) (Fst (D y))) (Sub (Snd (D x)) (Snd (D y)))) :ruleset deriv)
(rewrite (D (Mul x y)) (Pair (Add (Fst (D x)) (Fst (D y))) (Add (Mul (Snd (D x)) (Fst (D y))) (Mul (Fst (D x)) (Snd (D y))))) :ruleset deriv)
(rewrite (D (Div x y)) (Pair (Add (Fst (D x)) (Fst (D y))) (Div (Sub (Mul (Snd (D x)) (Fst (D y))) (Mul (Fst (D x)) (Snd (D y)))) (Pow (Fst (D y)) (Const 2.)))) :ruleset deriv)
(rewrite (D (Pow x y)) (Pair (Add (Fst (D x)) (Fst (D y))) (Mul (Add (Div (Mul (Snd (D x)) (Fst (D y))) x) (Mul (Snd (D y)) (Log (Fst (D x))))) (Pow (Fst (D x)) (Fst (D y))))) :ruleset deriv)

(rewrite (D (Neg x)) (Pair (Neg (Fst (D x))) (Neg (Snd (D x)))) :ruleset deriv)
(rewrite (D (Exp x)) (Pair (Neg (Fst (D x))) (Mul (Snd (D x)) (Exp (Fst (D x))))) :ruleset deriv)
(rewrite (D (Log x)) (Pair (Neg (Fst (D x))) (Div (Snd (D x)) (Fst (D x)))) :ruleset deriv)
(rewrite (D (Sin x)) (Pair (Neg (Fst (D x))) (Mul (Snd (D x)) (Cos (Fst (D x))))) :ruleset deriv)
(rewrite (D (Cos x)) (Pair (Neg (Fst (D x))) (Mul (Snd (D x)) (Neg (Sin (Fst (D x)))))) :ruleset deriv)

(rewrite (D (Build n f)) (Build n (D f)) :ruleset deriv)
(rewrite (D (IFold f z n)) (IFold (D f) (D z) n) :ruleset deriv)
(rewrite (D (Get a i)) (Get (D a) i) :ruleset deriv)

(rewrite (D (Pair x y)) (Pair (D x) (D y)) :ruleset deriv)
(rewrite (D (Fst x)) (Fst (D x)) :ruleset deriv)
(rewrite (D (Snd x)) (Snd (D x)) :ruleset deriv)

(constructor Diff (Expr) Expr :unextractable)
(rewrite (Diff f) (Lam (App (D f) (Pair (Var 0) (Const 1.)))) :ruleset deriv)

(constructor Grad (Expr) Expr :unextractable)
(rewrite (Grad f) (Lam (Build (Length (Var 0)) (Lam (App (D f) (VectorZip (Var 1) (VectorHot (Length (Var 1)) (Var 0))))))) :ruleset deriv)
