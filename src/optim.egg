(ruleset optim)

(constructor Shift (i64 i64 Expr) Expr :unextractable)
(rewrite (Shift c d (Lam f)) (Lam (Shift (+ c 1) d f)) :ruleset optim)
(rewrite (Shift c d (App f x)) (App (Shift c d f) (Shift c d x)) :ruleset optim)
(rewrite (Shift c d (Var n)) (Var n) :when ((< n c)) :ruleset optim)
(rewrite (Shift c d (Var n)) (Var (+ n d)) :when ((>= n c)) :ruleset optim)
(rewrite (Shift c d (Prim p)) (Prim p) :ruleset optim)
(rewrite (Shift c d (Int i)) (Int i) :ruleset optim)
(rewrite (Shift c d (Real x)) (Real x) :ruleset optim)

(constructor Subst (i64 Expr Expr) Expr :unextractable)
(rewrite (Subst n e (Lam f)) (Lam (Subst (+ n 1) (Shift 0 1 e) f)) :ruleset optim)
(rewrite (Subst n e (App f x)) (App (Subst n e f) (Subst n e x)) :ruleset optim)
(rewrite (Subst n e (Var n)) e :ruleset optim)
(rewrite (Subst n e (Var m)) (Var m) :when ((!= n m)) :ruleset optim)
(rewrite (Subst n e (Prim p)) (Prim p) :ruleset optim)
(rewrite (Subst n e (Int i)) (Int i) :ruleset optim)
(rewrite (Subst n e (Real x)) (Real x) :ruleset optim)

(rewrite (App (Lam f) x) (Shift 0 -1 (Subst 0 (Shift 0 1 x) f)) :subsume :ruleset optim)

(function FreeVars (Expr) VarSet :merge (set-intersect old new))
(rule ((= (Lam f) e) (= (FreeVars f) vs)) ((set (FreeVars e) (set-shift vs))) :ruleset optim)
(rule ((= (App f x) e) (= (FreeVars f) vf) (= (FreeVars x) vx)) ((set (FreeVars e) (set-union vf vx))) :ruleset optim)
(rule ((= (Var n) e)) ((set (FreeVars e) (set-of n))) :ruleset optim)
(rule ((= (Prim p) e)) ((set (FreeVars e) (set-empty))) :ruleset optim)
(rule ((= (Int i) e)) ((set (FreeVars e) (set-empty))) :ruleset optim)
(rule ((= (Real x) e)) ((set (FreeVars e) (set-empty))) :ruleset optim)

(rewrite (App (App (App (Prim (IFold)) (Lam (Lam (App (App (App (Prim (If)) (App (App (Prim (EQ)) (Var 0)) e0)) e1) (Var 1))))) z) n) (Shift 0 -2 (Subst 1 (Shift 0 2 z) (Subst 0 (Shift 0 2 e0) e1))) :when ((set-not-contains (FreeVars el) 0) (set-not-contains (FreeVars e0) 1)) :subsume :ruleset optim)

(unstable-combined-ruleset both deriv optim)
